​	各位评委老师，大家好！我是来自PO的Jake。今天，我将和大家分享我们团队在PR Approval Control Panel项目中的进行的一些实践，以及获得的成长。

​	首先，直奔主题，简要介绍一下这个项目的情况。我们的PO系统主要用于向Vendor下采购单。若PM想创建一个采购单，需要先提交一个采购申请。当然，PM不能想买什么就买什么，想买多少就买多少。PO系统将根据一些特定的规则对每个采购申请进行审批。但是，规则本身并不是一成不变的，随着业务和销售情况的变化，规则也需要做出相应的变化。用户希望能够手动配置这些审批规则。本次项目提供的这个页面，便是用于对一些审批规则进行配置。同时，不同BU的规则可能是不同的，故需要支持对不同BU进行不同的配置。这就是这个项目的背景与需求。最终实现的UI效果如下。

​	从业务和功能上来看，这个项目没有什么特别之处。但是，作为我们团队参与“服务化”半年之后的一次实践，同时也是PO系统迁移的第一步，我们在这个项目中做出了一些自我突破。概括起来，主要有三方面内容：“新的理念”，“新的工作模式”和“新的技术”。接下来我将为大家介绍，我们团队是如何在本次项目中实践这些“新的东西”。

### 1.新的理念

​	跳出这个项目，我想先介绍一下PO系统的现状。PO系统是一个历史悠久的系统。经过多年的开发与维护，功能已经趋于稳定，这是好的一方面。但另一方面，团队的主要工作已经变为无休止地对系统进行小修小补，团队成员普遍感觉缺乏成长，缺乏成就感。同时，PO系统已经积累了太多的历史包袱，在技术、性能、维护性、用户体验等各方面都已落后。总之，无论是团队还是系统，都亟待一场彻底的变革。

​	于是，借由参加“构建服务化团队”这个契机，我们从繁重的业务项目中抽离出来，重新审视PO系统，思考我们工作的方式与意义。最终，我们树立了“构建优秀的团队，打造好用的产品”的理念。

​	在服务化会议上，James的一句话让我印象深刻，他说“先有团队，后有产品”。对此我们的理解是，我们应首先作为一个独立的团队而存在，而不是将自己绑定在某个业务系统上。应该由“团队定义产品”，而不是由“产品定义团队”。

​	这样的理念带给我们最核心的改变其实就是三个字——“主动性”。我们开始主动去做一些工作，让产品变得更好用，也让团队成员工作得更舒心。

​	

### 2.新的工作模式

​	以前，我们的工作模式基本上是处于“BSD怎么说，我们怎么做”的被动状态，BSD实质上充当了“产品经理”的角色，掌控着产品的发展。我们只对BSD负责。BSD在业务问题上自然是非常专业，但他们的关注点更多的在于“把业务功能实现”，而对于”用户体验“、”业务领域划分“、”可维护性“、”可扩展性“等问题则不会考虑太多。举个例子：页面下的按钮。

​	其次，BSD对于业务细节并不是那么熟悉，甚至于不在乎。

​	另外，BSD通常并不是我们系统的真正使用者，仅仅通过BSD我们很难及时、准确地获取实际用户的反馈。

​	有感于以上这些困扰，我们团队讨论后决定，应该由我们自己来主导产品的发展，对用户负责。把BSD当成我们的客户。具体来讲，我们做了以下一些与以往不一样的工作。

​	（1）梳理产品线，制定路线图。

​	梳理清楚自己团队到底有哪些产品是第一步。这一步并没有听起来那么容易，因为以前我们并没有“产品”的概念，只有“页面”的概念。这也导致我们的系统业务领域划分不清晰，维护难度大。经过一些讨论，我们最终确定了自己的产品线。

​	接下来我们为每个产品制定了短期和长期的路线图，作为我们工作的指导。具体到PO这个产品，从长远来看，我们希望经过以下三个阶段，将PO打造为一个现代化的产品。

​	第一步，产品化。主要是  将PO迁移至新的技术平台，偿还技术债务。

​	第二步，智能化。主要是将PO系统打造为智能化程度高、用户体验极好的产品。

​	第三步，自动化。主要是将PO系统转变为全自动化的供应链管理系统。

​	目前我们正在进行第一步。

​	（2）制定文档规范，严格要求质量

​	文档是产品的基石。我们以前对于文档并没有规范化的要求，导致产品文档要么缺失，要么过时，要么格式不统一。现在，我们制定了严格的产品文档规范，并通过Confluence建立了模板，规范化每个人写的文档。模板包括需求分析、设计、Release以及最终的产品文档，涵盖整个开发周期。同时，将文档工作明确纳入开发流程，保障文档的及时创建和更新。

​	（3）提炼业务模型，指导业务开发

​	我们总结出了各业务领域最核心的业务模型。然后基于业务模型来进行需求分析和设计，考虑如何将新的功能融入到现有的流程中。摒弃以往在一个页面上不断堆砌功能按钮的开发模式。

​	（4）开发保证质量，测试逐步退出功能测试

​	我们要求，开发人员撰写自测用例，并且执行测试，作为开发流程的一部分。测试人员对自测用例进行Review，检查是否覆盖主要功能点。确认覆盖率足够之后，测试人员再接收项目，进行测试。目前测试人员依然会对开发测试过的用例进行测试，以确保质量。今后将逐步进行抽查，直至完全退出功能测试。（本次项目的测试情况）

​	（5）收集用户反馈

​	我们将收集用户反馈也作为项目开发周期的一部分，主要由测试人员负责。用户反馈包括开发中和上线后两种。在开发中我们会尽早邀请用户体验，尽快获得用户反馈。反馈得越早，我们修改和调整的难度越小，项目也越能满足用户需求。而上线后，目前我们主要使用三种方式获取用户反馈：

* 问卷调查

* 用户操作记录

* 系统提供的主动反馈功能、

  上线后的用户反馈将作为我们今后工作的重要参考。

  结合以上工作，我们形成了新的工作流程：

  需求分析->设计->UI Demo（用户，UI）->开发->自测->测试验收->执行测试（用户使用）->Release->文档完善->收集反馈

  短期来看，新的工作流程增加了很多环节，延长了开发时间。但长远来看，由于开发质量高、文档完备，我们在测试、维护和扩展时，将节约大量的时间。

### 3.新的技术

​	技术是业务的支撑，也是一个团队的核心竞争力。在PO系统的迁移过程中，我们使用了一系列新的技术，全面提升了产品的性能、可维护性、可扩展性以及用户体验。

（1）前端技术

​	前端方面，我们使用了Newkit框架作为基础框架。Newkit基于Angular框架开发，并提供了很多开箱即用的组件与服务，为我们前端开发提供了坚实的支撑。

​	在此基础上，我们引入了ngrx库，用Redux的单向数据流的理念来管理应用状态，使整个应用的数据流转清晰、可预测。在开发过程中，借助于Redux开发者工具（Redux-Dev-Tool），我们可以追踪应用中触发的各种Action及应用状态的变化过程，极大提升了开发体验和开发效率。我们可以做一个演示。如图，左边是我们的应用，右边是Redux开发者工具。通过导航栏打开我们的应用。随着加载完成，我们可以看到开发者工具中列出了加载过程中触发的Action，以及Action导致的应用状态的变化。我们再切换一个BU试试，可以看到新的Action以及对应的状态变化。不仅如此，通过Time-Travel功能，我们可以回溯应用生命周期中的每个状态。这非常有助于我们查找，到底是哪一步导致应用状态异常。

​	另外，我们使用了RxJS库，以”函数响应式编程（FRP）“的方式编写代码。通过”可观察流（Observable）“这种抽象概念，可以轻松地处理各种同步和异步依赖。举一个简单的例子，本次项目提供了一个Filter功能，根据用户的输入来过滤表格中的记录。为了更好的用户体验，我们希望用户输入完成后，才开始执行过滤操作。我们定义“输入完成”的含义为“输入在400ms内不再发生变动”。另外，如果两次输入的数据相同，则不应执行过滤操作。要实现这个功能，我们可以将Input输入框输入的出数据抽象为一个“可观察流”，然后利用RxJS提供的操作符来构建数据管道对其进行过滤，将其映射为一个符合我们期望的输入流。（如图所示）只需要几行代码就可以实现这个稍显复杂的功能，代码风格非常类似于C#中的Linq。this.value$$代表实际的用户输入流，debounceTime操作符负责过滤数据，只有当指定时间内源数据流不再产生新数据，他才会允许数据通过。distinctUntilChanged操作符则只在前后两次数据不相同时，才允许数据通过。subscribe代表订阅，当满足条件的数据产生时，执行指定的操作。再举一个较为复杂的例子。我们页面上这个表格中的显示的数据，实际上依赖于当前Tab、当前BU、API端返回的数据、Filter值、当前分页情况以及当前排序情况等多个数据源，其中既有同步的数据也有异步获取的数据（比如BU）。要处理如此复杂的依赖，通过常规的方式很难实现。利用RxJS，可将每个数据源都抽象为一个可观测流，然后将它们组合、过滤，构建数据管道，最终生成代表表格中当前数据的流，然后将该结果流绑定到UI上即可。此后每当有任何一个数据源更新，都可通过数据管道即时反应到结果流中，进而触发UI更新。

（2）后端技术

​	在后端方面，我们开始尝试向”微服务“方向发展。第一步，是将原来的单块架构，依据业务领域的划分拆分为多个小型服务。目前，我们已经将”邮件服务“和”MoOffice服务“拆分为独立的项目。

​	在后端框架方面，我们选择了基于.NET Core的Web API框架。随着2.0版本的发布，.NET Core已经非常成熟。优秀的架构、卓越的性能、优雅的语法，再加上跨平台的特性，使.NET Core成为我们的首选。在此基础上，我们以Nuget包的形式封装了公司和团队内的各种公共服务。同时，为了同时访问公司内网和外网的Nuget，我们自行搭建了一个Nuget仓库。另外特别值得一提的是，在数据库访问方面，我们原来使用的是.NET Core版本的Dapper。但使用中发现，有一些特性并不支持。于是，我们转而使用了自己开发的DataAccess库，实际使用中表现优异。

（3）API自动化测试

​	本次项目我们对每个API实施了自动化测试。保证了测试效率和可回归性。自动化测试通过DAE继承在持续集成流程中，自动执行。

（4）开发、测试和部署流程

​	在前端项目流程中，我们依然和以前一样，使用Jenkins搭建持续集成流程，最终自动生成发布包。

​	在后端项目流程中，我们充分利用了公司内部资源，自动化一切可以自动化的步骤。首先，我们在DAE上定制了PO的Web API项目模板，并用它搭建API项目。DAE平台提供了单元测试、集成测试和GDEV、GQC测试环境，极大地减轻了手动搭建继续集成流程工作量。不过可惜的是，DAE不提供PRE和PRD环境。于是，在需要部署到PRE和PRD时，我们使用脚本将DAE生成的Docker镜像部署至Humpback平台。脚本可通过Jenkins一键执行。另外，由于.NET Core的跨平台特性，我们得以部署在Linux上，减少了对于Windows Server的依赖。

### 4.总结

​	总结一下，通过本次项目，我们实践了新的理念、新的工作模式、新的技术，积累了丰富的经验，为PO系统的下一步发展打下了坚实的基础。



​	

​	







